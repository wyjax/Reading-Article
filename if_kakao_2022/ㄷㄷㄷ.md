# ㄷㄷㄷ

### 들어가기 전에

- 경우에 따라 DDD 기술 규칙과 패턴이 DDD 구현에 방해가 될 수 있음 → 중요한 것은 패턴이 아니라 비지니스 문제에 맞게 코드를 구성하고 동일한 비지니스 용어를 사용하는 것

### 기존 개발

- 기획서를 받으면 DB 스키마를 먼저 고민 → RDBS의 정규화에 대해서 고민
- 그리고 스키마가 정해지면 똑같은 클래스를 만들고 거기에 맞춰서 비지니스 로직을 구현
- DB 스키마는 개발자의 전유물이지만 기획자, 운영 업무자는 DB 스키마와는 동떨어진 업무를 진행 → 개발자는 DB 중심으로 생각하고 운영자는 기능 중심으로 생각
- 이런 불일치는 커뮤니케이션 비용을 낭비 혹은 잘못된 소프트웨어를 만드는 원인

### 도메인 주도 설계

- 위와 같은 불일치를 해결하기 위해서 나온 노력 중 하나가 DDD
- 감히 한 문장으로 설명하자면 **도메인 모델의 적용 범위를 구현까지 확장하여 도메인 지식을 구현 코드에 반영하는 것**
- 설계를 완벽하게 하고 구현을 하라는 것이 아님 → 설계와 구현을 반복적으로 해야함 → 약간 애자일스럽게...
- 도메인에 대해서 100% 이해하기 위해서 문서로는 부족 → 실제 몸으로 겪어봐야 하는데 이게 코드를 구현하는 일
- 그래서 이런 것들을 도와주기 위해서 다양한 원칙과 패턴이 존재
- 도메인 주도 설계를 이해하기 위해서 세가지 기둥이 있는데 아래와 같음
    - 전략적 설계
        - 도메인을 거시적 관점으로 보는 개념 → 나무가 아닌 숲을...
        - Bounded Context를 추출하는 개념이라고 생각
        - Event Storming
            - 전략적 설계를 위해서 사용되는 방법론으로, 비즈니스 규칙, 시스템내의 프로세스에 대한 Big picture를 구성하기에 좋은 방법론
            - Event Storming 과정을 거치고 나면 요구사항으로부터, Bounded Context와 주요 Aggregate 단위들, Domain Event들, 구현의 단위들을 추출
    - 전술적 설계
        - 전략적 설계를 도와줄 실제 구현 패턴을 의미
        - Bounded Context를 aggregate, entity, service, repository등의 요소들을 활용하여 구성하는 것이 목적
        - 전술적 설계를 모아두는 것을 DDD Lite라고 함
            - DDD Lite는 어찌보면 부정적인 의미
            - 전술적 설계만을 가지고 DDD를 하게되면 전략적 설계 즉 거시적인 관점을 놓치게 됨
    - 유비쿼터스 언어

### 도메인

- 내가 만들고 있는 서비스 혹은 소프트웨어가 영향력을 미치는 곳 → 즉 소프트웨어가 어떠한 문제를 해결하고자 하는 영역
- 쇼핑몰을 운영하고 있음 → E-Commerce가 나의 도메인 영역이 됨
- 도메인은 다시 하위 도메인으로 나눌 수 있음
    - 쇼핑몰에는 회원, 카테고리, 주문, 상품 등의 하위 도메인이 존재

### 도메인 모델

- 모델 → 내가 다루고 있는 도메인을 개념적으로 표현한 것 (클래스다이어그램 같이...)
- 아까 도메인은 어떠한 문제를 해결하고자 하는 영역이라고 했는데
- 이걸 합쳐서 도메인 모델은 내가 관심이 있는 특정 도메인 영역을 개념적으로 표현한 것이라고 할 수 있음
- 개발자만의 것이 아니라 기획자, 운영자 등 필드에 속한 사람들이 대화할 때 쓰는 도구가 도메인 모델이라고 할 수 있음
- 그래서 도메인 모델 설계는 이러한 모델들을 실제 구현까지 끌고 가는 것을 의미
- 효과적인 도메인 모델링을 위해서는 클래스다이어그램 UML로 한정되어선 안됨 → 어떠한 설명을 돕기위한 낙서 등이 오히려 더 도움이 될 수 있음

### 유비쿼터스 언어

- 유비쿼터스 → 언제 어디서나 라는 뜻
- 공통된 하나의 언어 → A라는 사물이 있을 때 누구는 ‘가'라고 부르고 ‘나'라고 부르면 안되고 ‘가'라는 것을 불렀을 때 다른 사물을 떠올리면 안됨
- 개발자는 유비쿼터스 언어를 실제로 코드로 녹일 수 있도록 노력해야하고 기획자는 문서에 이 언어가 나타나도록 노력, 디자이너는 프로토타입에 이 언어가 나타나도록 노력
- 용어 사전에 기록을 한다던가 등의 노력을 해야함

### BOUNDED CONTEXT

- 도메인마다 같은 용어라도 의미가 다르고 같은 대상이라도 지칭하는 용어가 다를 수 있음 → 한 개의 모델로 모든 하위 도메인을 표현하면 안됨
- 모델은 특정한 컨텍스트하에 완전히 다른 의미를 가질 수 있음 그래서 도메인과 유비쿼터스 언어는 컨텍스트 안에서 정의를 해야 함
- 이런 컨텍스트 경계를 BOUNDED CONTEXT라고 함
- customer 도메인에 대해서 sales context에서는 판매라는거에 관심을 갖지만, cs context에서는 불편사항에 대해서 관심을 갖음
- 근데 문제점은 customer를 sales용으로 사용하고 cs용으로 사용함
- 좋은 BOUNDED CONTEXT
    - 하나의 BOUNDED CONTEXT는 하나의 팀에만 할당
    - 각각의 BOUNDED CONTEXT는 각각의 개발 환경을 가질 수 있음 → MS

### DDD 도입이 어려운 이유

- 내 도메인에만 관심이 있고 다른 도메인에 대해서 관심이 없는 경우
- 동일한 개념에 대해서 다른 용어를 사용하는 경우, 다른 개념에 동일한 언어를 사용하는 경우
- 신규 작업을 하려고할 때 히스토리 파악을 위해서 동료 A, 동료 B 등등에게 물어봐야함
    - A → B → C → .... 퇴사?
    - 도메인 모델링의 파편화 → 지식을 모으기가 어려움
- 지식을 모으는 방법 → Event Storming
    - Event Storming 워크샵을 진행 → 길게는 하루 짧게는 3시간정도 post it으로 도메인 공부를 진행

### 도메인 주도 설계 기본 요소

- 엔티티
    - 식별자를 갖음
    - 식별자는 엔티티 객체마다 고유해서 각 엔티티는 서로 다른 식별자를 갖음
    - 예를들어 주문의 경우 주문번호라는 식별자를 갖음 → 주문에서 배송지 주소가 변경된다고 해서 주문번호가 변경되지 않음
    - 엑티티 식별자는 바뀌지 않고 고유하기 때문에 식별자가 같다면 두 엔티티는 같다고 판단
    - 식별자만으로 equals()와 hashcode()를 구현 가능
- 밸류 타입
    - 값 자체가 식별자 (firstName + lastName 을 합친 것이 식별자)
    - 의미를 명확하게 표현하거나 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 사용
    - 값 객체라서 불변이란 특징 → 안정성을 보장 받음
    - 불변이기 때문에 밸류 객체의 값을 변경하는 것은 새로운 객체를 할당
    - 항상 equals()와 hashcode()를 구현해야 함
- 언제 엔티티를 쓰고 밸류 타입을 써야하나?
    - 가장 큰 기준은 값이 지속적으로 변화하고 값이 변하더라도 참조를 유지해야할 때 엔티티로 만듦
    - 자동차의 바퀴는 밸류 타입이 될 수 있음 하지만 바퀴를 파는 입장에서는 바퀴는 엔티티가 되어야 함 → CONTEXT가 분리되는 현상
- 엔티티와 밸류 타입
    - 식별자는 보통 Long 타입으로 구성되는 경우가 많은데 밸류 타입으로 그 의미를 좀 더 명확하게 할 수 있음
- 도메인 모델에 set 메서드 넣지 않기
    - changeShippingInfo() vs setShippingInfo()
- 도메인 객체(엔티티, 밸류, 도메인 서비스)에서 이벤트를 주로 발행
    - 이벤트는 변경과 관련된 것 근데 변경은 도메인에서 변경이 됨 그래서 도메인에 위치하는 것이 맞음

### 에그리거트(트랜잭션의 단위)

- 아까 봤던 엔티티나 밸류 타입을 하나로 묶은 군집
- 에그리거트로 묶으면 모델들이 어떻게 커뮤니케이션하는지 상위 수준에서 알 수 있음
- 에그리거트는 동일한 라이프사이클을 갖는 것들끼리 묶음
    - Order, Address, OrderItem → 여기서 Order는 에그리거트 루트
        - 보통 외부에서 참조하는 엔티티를 어그리거트 루트로 뽑음
        - 에그리거트의 내부 구현을 숨길 수 있음 → 반장에게 학습지를 나눠주는 것과 같은 이치
        - JPA의 Cascade.ALL + orphanRemoval = true → 어그리게이트 루트를 바라보고 생명주기가 같은 것들은 함께 생성되고 함께 사라짐
    - JVM 혹은 DB상에서 Order 객체가 사라지면 Order Address OrderItem이 같이 사라지고 생성되어야 함
- Projection : 현재 가지고 있는 데이터가 어떤 것인지 표현해 줄 수 있는 개념

### 레파지토리

- 레파지토리는 에그리거트 단위로 저장하고 조회하는 기능을 담당
- 한번 저장하면 에그리거트에 속한 모든 엔티티 및 밸류 타입을 저장하고, 조회할때도 마찬가지
- 레파지토리는 테이블 단위가 아닌 레파지토리 단위로 존재
    - Order, OrderItem 테이블이 있닫고 OrderRepository, OrderItemRepository를 만들지 않음

### 도메인 서비스

- 하나의 에그리거트에 넣기 애매한 도메인 개념을 구현하려면 애그리거트에 억지로 넣기보다 도메인 서비스를 이용해서 명시적으로 드러냄
    - 회원 : 등급별 할인
        - 결제금액을 계산해야하는 주체는 어느 애그리거트인가? → 도메인 서비스에 넣자
    - 쿠폰 : 쿠폰별 할인
    - 주문 : 상품별 개수
- 애프리케이션의 서비스 로직은 응용 로직을 다룬다면, 도메인 서비스는 도메인 로직을 다룸
- 도메인 서비스는 상태가 없고 행위만 다룸
- 서비스를 사용하는 주체는 응용 서비스가 될 수도, 도메인이 될 수도 있음
- 관련 로직을 한곳에 모았기 때문에 보통 절차적일 확률이 높음 → 하지만 한 곳에 모아뒀기 때문에 유지보수하기 편함
- 도메인 서비스는 validation같은 것...

### 도메인 주도 설계 아키텍처 개요

- Domain 계층에 비지니스 로직 수행
- 계층형 아키텍처(Layer 아키텍처)
    - **프레젠테이션 레이어**
        - 어플리케이션 레이어에서 만든 데이터를 사용자 화면에 제공
        - 제공하는 방법은 HTTP, TCP, RCP 등.. → 어떤 데이터를 어떻게 제공할 것인가에 대한 관심

        **어플리케이션 레이어**

        - 사용자의 요청을 처리하기 위한 작업, 시스템이 사용자에게 제공해야 할 기능을 구현
        - 레파지토리로부터 에그리거트를 조회 → 에그리거트에게 메시지를 던지고(도메인 모델을 활용해서 기능을 구현) → 에그리거트의 결과를 토대로 사용자에 제공
        - 즉, 어그리거트들 간의 실행 흐름을 제어
        - 트랜잭선 처리 → 논리적인 트랜잭션이 에그리거트라면, 물리적인 트랜잭션은 어플리케이션 레이어에서 진행
        - 도메인 영역에서 발생시킨 이벤트를 처리
        - 응용서비스에 넘어가는 값이라던가 파라미터의 종류가 많다면 별도 클래스로 만들 수 있음 → DTO

        **도메인 레이어**

        - 도메인의 비지니스 로직

        **인프라스트럭처 레이어**

        - 논리적인 개념을 표현하기 보다는 실제 구현을 담당
        - RDBMS 연동을 처리
        - 메시징 큐에 메시지를 전송하거나 수신하는 기능을 구현
        - Redis와의 데이터 연동을 처리
        - SMTP를 활용한 메일 발송 기능을 구현하거나 HTTP 클라이언트를 활용해 REST API를 호출하는 것도 처리
    - 상위 레이어는 하위 레이어에 대해서 알고 있지만(의존하지만), 하위 레이어는 상위 레이어에 대해서 모름

### DTO

- 프로세스 간에 데이터를 전달하는 객체
- Domain Model Everywhere 의 입장
    - 잘만든 객체를 레이어가 넘어가더라도 그대로 사용
    - 장점으로는 이미 있는 객체를 사용하기 때문에 개발이 빠름
    - 단점
        - 자바 Beans 규약에 따라 getter(), setter() 메소드에 따라서 데이터 추출, 세팅 및 (역)직렬화
        - 자바 Beans를 사용하지 않는 라이브러리는 리플렉션을 활용해서 데이터 추출, 세팅 및 (역)직렬화
        - 스프링에서는 GET 메소드로 온 데이터들은 getter, setter를 활용해서 테이터 세팅
        - POST메소드로 BODY에 온 데이터는 ObjectMapper을 통해 리플렉션 기술로 데이터 세팅
        - 내가 사용하는 프레임워크 때문에 도메인 모델에 getter(), setter()가 강제적으로 들어가게 되는 경우가 생김
        - 도메인 모델에 여러가지 기술적 침범이 발생
- Pure Domain Model
    - 애플리케이션의 외부 요구 사항(클라이언트의 요구 사항 - 요청과 응답 데이터)과 내부 요구사항을 분리

### 이벤트 적용 시 주의해야할 점

이벤트 소스를 이벤트 엔트리에 추가해야할지 여부

- 이벤트 발생 주체를 비지니스 적으로 알아야 한다면 추가

포워더에서 전송 실패를 얼마나 허용할 것인가?

- 포워더는 이벤트 저장소에서 데이터를 읽어서 이벤트 핸들러에게 전송
- 만약 이벤트 전송이 실패한다면 다시 읽어서 전송하지만, 특정 이벤트에서 계속해서 실패한다면 나머지 이벤트들은 대기상태
- 실패한 이벤트의 재전송 횟수 제한을 두어야 함

이벤트 순서에 대한 고려

- 이벤트 저장소를 활용하는 방법
- 메시징 시스템은 사용 기술에 따라서 이벤트 발생 순서와 처리 순서가 다를 수 있음

이벤트 재처리에 관련되 것

- 회원 가입 신청 이벤트가 처음 도착하면 메일을 발송해야하는데
- 동일한 순번의 이벤트가 다시 들어오면 이메일을 발송하지 않는 방식을 고려해야 함

### CQRS

- Command (명령) / Query (쿼리) / Responsibility (책임) / Segregation (분리)
- 명령(주문 취소, 배송 완료 등)의 역할을 수행하는 책임과 쿼리(주문 조회, 배송 조회)의 역할을 수행하는 책임을 분리하는 것
- 중복되는 코드도 많은데 왜 하는걸까?
    - 한 모델이 여러 기능을 넣다보니 책임이 모호해지고 가독성 등 유지보수성이 떨어짐
    - 그러다보니 기능에 따라서 실제로 사용하는 속성이 다르게 객체를 생성하게 됨


### Event Storming

큰 벽 (칠판) 그 위에 종이를 붙이도록

우리가 사용하는 스티커 색이 어떤 역할을 하는지 공유

좌석이 없음 모두가 서서 함

개발자 뿐아니라 실무진들을 한곳에 모아서 진행을 해야함

이벤트 스토밍을 통해서 도출되는 결과는 아래와 같음

여러가지 색의 스티키 노트와 Bounded Context

이벤트 스토밍을 통해서 어떤 비지니스의 흐름을 알 수 있고 그것으로부터 도출된 BoundedContext로부터 전체적인 맵이 나오게되고 쉽고 간결하게 모두가 모여서 하나의 그림으로 이해할 수 있음

간단한 펜

주황색 스티커

- 이벤트를 도출할 때 사용
- 사용자도 이벤트를 받고 일어나고 시스템 안에서도 이벤트가 받고 일어남
- 상태가 바뀌는 것이 이벤트
- 이벤트는 과거형 수동형으로 사용
- Item added to cart

파란색 스티커

- 이벤트를 일으키는 명령
- 이 명령에 의해서 이벤트가 일어나게 됨

노랑색 스티커

- Aggregate
- 상품의 아이템 → 이름 아이디 수량 코드 등이 존재
- Aggregate와 Aggregate 사이에는 참조가 아니라 id를 서로 가지고 있음
    - API 호출을 통해서 느슨하게 관계를 맺도록 설정


파랑색에 의해서 → 노랑색이 → 주황색 스티커를 일으킴

노랑색와 주황색은 원자성을 가지고 항상 같이 일어나게 됨

Repository는 데이터 모델 영역에 있어야함 → POJO여야하는데.. 스프링의 Repository를 상속해서 사용하고 있음

→ Trade off

Entity도 사실 POJO여야하는데 침범당하고 있음